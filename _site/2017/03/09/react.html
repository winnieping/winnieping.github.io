<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<link rel="stylesheet" href="/styles/css/index.css">
		<title>React</title>
　　</head>
　　<body>
　　　　	<div class="container">
	<div class="left">
		<div class="content">
			<div class="logo">
				<img src="/../assets/logo.jpg" alt="logo">
			</div>
			<div class="motto">依你之萍</div>
			<div class="navigation">
				<span class="btn pink">
					<a href="http://localhost:4000">
						<img src="/../assets/home.png" alt="home">
					</a>
				</span>
				<span class="btn white">
					<a href="http://weibo.com/u/2627764953" target="_blank">
						<img src="/../assets/weibo.png" alt="weibo">
					</a>
				</span>
				<span class="btn pink">
					<a href="https://github.com/winnieping" target="_blank">
						<img src="/../assets/github.png" alt="github">
					</a>
				</span>
				<span class="btn white">
					<a href="/2016/02/01/list.html">
						<img src="/../assets/note.png" alt="note">
					</a>
				</span>
			</div>
		</div>
	</div>
	<div class="right">
		<p>React并不是一个MVC框架，只是一个用于构建UI的javascript库。  React一般也叫React.js，起源于facebook，提倡用可重用的组件来表现随时间变化的数据。
<!--break--></p>
<h4 id="1react生命周期">1.React生命周期</h4>
<p>组件挂载：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>constuctor()
componentWillMount()
render()
componentDidMount()
</code></pre></div></div>

<p>组件更新：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>componentWillReciveProps()
componentShouldUpdate()
componentWillUpdate()
render()
componentDidUpdate()
</code></pre></div></div>

<p>组件卸载:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>componentWillUnMount()
</code></pre></div></div>

<h4 id="2react虚拟dom">2.React虚拟Dom</h4>

<p>React render()执行后得到什么？？？得到的并不是真正的Dom节点，而是虚拟Dom。</p>

<p>Virtual DOM + Batching（批处理）+ Diff（算法）</p>

<p>Virtual DOM</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>虚拟dom实际上就是js画出来的一个画面，存在于内存。直接操作这个画出来的东西，不需要进行dom渲染，所以无论多么频繁操作虚拟dom，速度都很快。
</code></pre></div></div>

<p>Batching</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>将所有的DOM操作搜集起来，一次提交给真实DOM。 
</code></pre></div></div>

<p>Diff（算法）</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>比较DOM虚拟节点树
1、节点类型不同	销毁节点，插入新节点
2、节点类型相同，属性不同	（对属性进行重设）
	在同一层	添加Key，插入或删除新节点
	不在同一层	销毁并重建
</code></pre></div></div>

<p>总结：diff算法对比之前的DOM树，得出变化</p>

<p>​			    batching将变化提交给真实DOM</p>

<h4 id="3路由">3、路由</h4>

<p>React是单页面开发，使用React-Router 实现路由跳转</p>

<p>我们知道window对象的location对象有以下属性：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Location{
    hash:""
    host:"localhost:4000"
    hostname:"localhost"
    href:"http://localhost:4000/2016/02/01/list.html"
    origin:"http://localhost:4000"
    pathname:"/2016/02/01/list.html"
    port:"4000"
    protocol:"http:"
    search:""
}
</code></pre></div></div>

<p>其中hash的定义是url改变该部分不会影响页面重新加载的部分，所以我们知道可以用hash来实现单页面的路由跳转。</p>

<p>要实现无刷新跳转还可以用 HTML5 的 History API</p>

<p>总结以上两种方法就是react实现路由跳转的两种方式：</p>

<p>hashHistory 和 browserHistory</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hashHistory 	url带#
browserHistory 	需要server 端配置
</code></pre></div></div>

<h3 id="4react性能">4、React性能</h3>

<p>一、减少render() 执行次数</p>

<p>比如父组件更新导致子组件不必要的更新，在shouldComponentUpdate（）中操作。</p>

<p>二、使用immutable.js</p>

<h4 id="5高阶函数">5、高阶函数</h4>

<p>1、定义</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Concretely, a higher-order component is a function that takes a component and returns a new component.
</code></pre></div></div>

<p>具体来说，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。
2、eg：Redux</p>

<p>####6、setState实现机制</p>

<p>1、组件每次调用都是调用的React根组件的原型方法setState。</p>

<p>2、react 框架为了提高性能，会对 state 的更新进行收集、合并、再进行一次批量的状态更新
3、setState 会合并更新，可能会造成状态更新的丢失</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>handleClick = () =&gt; { this.setState({demo: this.state.demo + 1}); this.setState({demo: this.state.demo + 1}); } //click 之后 demo 为2而不是3
</code></pre></div></div>

<p>综上：在同一代码块中不要多次调用 this.setState 方法</p>

<p>4、setState会依次引发组件更新生命周期函数调用。</p>

<p>5、解决setState不会立即更新的办法</p>

<p>传入一个方法，返回你对state处理后的对象。而不是直接传入一个对象</p>

	</div>
</div>


　　</body>
</html>
