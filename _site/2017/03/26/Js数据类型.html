<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<link rel="stylesheet" href="/styles/css/index.css">
		<title>JavaScript数据类型</title>
　　</head>
　　<body>
　　　　	<div class="container">
	<div class="left">
		<div class="content">
			<div class="logo">
				<img src="/../assets/logo.jpg" alt="logo">
			</div>
			<div class="motto">依你之萍</div>
			<div class="navigation">
				<span class="btn pink">
					<a href="http://localhost:4000">
						<img src="/../assets/home.png" alt="home">
					</a>
				</span>
				<span class="btn white">
					<a href="http://weibo.com/u/2627764953" target="_blank">
						<img src="/../assets/weibo.png" alt="weibo">
					</a>
				</span>
				<span class="btn pink">
					<a href="https://github.com/winnieping" target="_blank">
						<img src="/../assets/github.png" alt="github">
					</a>
				</span>
				<span class="btn white">
					<a href="/2016/02/01/list.html">
						<img src="/../assets/note.png" alt="note">
					</a>
				</span>
			</div>
		</div>
	</div>
	<div class="right">
		<p>关于Javascript的数据类型、变量定义、隐式转换
<!--break--></p>
<h3 id="javascript数据类型变量定义隐式转换">Javascript数据类型、变量定义、隐式转换</h3>
<h4 id="1js数据类型">1、js数据类型</h4>

<p>五种简单数据类型</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>number、string、boolean、undefined、null
</code></pre></div></div>

<p>一种复杂数据类型</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object  包括数组，function，Date
</code></pre></div></div>

<p>（数组实际上是对象的一种特殊模式，只不过索引正好是整数）</p>

<p>其中number里有一种特殊数据 NaN。</p>

<p>typeOf返回的数据类型有：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>number 数字
string 字符串
boolean 布尔
undefined 未定义
object 对象或者null
function 函数
注意：null也是返回object
undefined 是指var声明变量 但是未对其加以初始化
null 	  是指一个空对象指针，这也是为什么typeOf(null)返回object
NaN		  非数值，表示本来要返回数值的操作未返回数值
既然数组也是对象的一组，如何区分呢？
instanceof 
var ss = [1,2,3];
ss instanceof Object	//返回true
ss instanceof Array		//返回true

instanceof扩展
释意：检测一个构造函数的原型属性所指向的对象是否存在于另一个要检测的对象的原型链上。
function Persion(){};
var persion = new Persion();
console.log(persion instanceof Persion);
</code></pre></div></div>

<p>null 和undefined 的区别</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>null 是指空对象，typeof（null） = "object"
undefined 是指定义的变量没有初始化 var a;console.log("a",a) = undefined
</code></pre></div></div>

<p>简单和复杂数据类型的存储</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>基本类型他们占据的空间是固定的，所以把它们存储在栈中，栈按照后进先出的原则存储数据。 

引用类型它们的大小是不固定的，所以不能存储在栈区，而是分配到堆区，堆区是内存中的动态区域，程序运行的时候动态分配给代码和堆栈，虽然这些数据大小不固定，但是地址的大小是固定的，所以我们在栈区存储对象在堆区的地址即可。这个地址即指针。
</code></pre></div></div>

<p><strong>由于js数据类型有两种，所以数据拷贝的时候会涉及浅拷贝和深拷贝两种</strong></p>

<h4 id="2定义变量的几种方法">2、定义变量的几种方法</h4>

<p>var let const 和全局变量</p>

<p>1、var 和 let的区别</p>

<p>es6之前，我们定义变量使用var，let的作用域比var更严格。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a = [];
for(var i=0;i&lt;10;i++) { 
    a[i] = function(){
        console.log(i);
    };
} 
a[6]();
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a = [];
for(let i=0;i&lt;10;i++) { 
    a[i] = function(){
        console.log(i);
    };
} 
a[6]();
</code></pre></div></div>
<p>由于js不存在块级定义域，所以第一个i溢出。而使用let定义变量，会有一个块级作用域的
概念，每次调用的时候let都是新的。</p>

<p>2、const定义不可改变的常量。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const pie = 3.1415926;
</code></pre></div></div>

<p>3、全局变量</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test = 222; //直接定义的就是全局变量
</code></pre></div></div>

<h4 id="3由var的作用域的思考">3.由var的作用域的思考</h4>
<p>之前提到js作用域只有全局作用域和方法作用域，但是为什么var定义的变量能在函数外被访问到呢。
我们来看两个例子。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(var i=0;i&lt;3;i++) { 
	var k = i + 1;
} 
console.log(i,k);
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function foo(){
	var a = 6;
	return a;
}
foo();
console.log(a);
</code></pre></div></div>
<p>为什么下面的a是undifind?
事实是：JavaScript以函数为界，每个函数内部拥有一个局部作用域；任何其他的块（包括普通代码块，for循环、if、while等代码块）不存在局部作用域，使用var声明的变量可以直接穿过这些代码块，可以被外部代码访问到。</p>
<h4 id="4隐式转换">4、隐式转换</h4>

<p>加号运算符有两个作用，字符串拼接和加法运算，所以
1、string和其他类型都会转为string进行字符串拼接。</p>

<p>2、没有string类型，所有数据转换为number进行运算。</p>

<p>减法运算符，所有的数据都会默认转为number类型进行运算。</p>

<h4 id="5常见的数据操作">5、常见的数据操作</h4>

<h5 id="51数组操作">5.1数组操作</h5>

<p>数组遍历 map（function（currentValue,index,array）{}）
数据插入 push（） unshift（）</p>

<p>数组截取 slice（） splice（index，howmany，item1……itemx）</p>

<p>数组去重如何实现</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function unduplicat(array){

	var result = [];

	array.forEach(function(value){

		if(result.indexOf(value) &lt; 0){

			result.push(value);

		}

	})

	return result;

}
</code></pre></div></div>

<p>数组扁平化如何实现</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var result=[];
var arr=[1, [2, [ [3, 4], 5], 6]];

function flat(arr,result){
	for(var i=0;i&lt;arr.length;i++){
    	if(typeof arr[i]==="number"){
        	result.push(arr[i]);
        }
        else{
        	flat(arr[i],result);
        }
    }
}
flat(arr,result);
console.log(result);
</code></pre></div></div>

<h5 id="52-字符串操作">5.2 字符串操作</h5>

<p>str.slice(start,end)
str.subString(start,end)</p>

<p>str.replace(‘’,’’)</p>

<p>Str.indexOf(‘’)</p>

<p>Str.split(分隔符，howmany)</p>

<p>slice（）和splice（）的区别</p>

<p>slice（）对字符串和数组都是截取，原有数组不会改变
splice（）是对数组的截取，返回被截取的元素，原有数组会改变</p>

<p>#####5.3 深拷贝与浅拷贝</p>

<p>关于深拷贝浅拷贝，之前有整理一篇文档，可以去看哦。</p>

	</div>
</div>


　　</body>
</html>
