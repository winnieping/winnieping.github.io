<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>JS函数 | Your awesome title</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="JS函数" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="函数定义，函数实参形参，匿名函数，自执行函数，闭包" />
<meta property="og:description" content="函数定义，函数实参形参，匿名函数，自执行函数，闭包" />
<link rel="canonical" href="http://localhost:4000/2018/01/30/Js%E5%87%BD%E6%95%B0.html" />
<meta property="og:url" content="http://localhost:4000/2018/01/30/Js%E5%87%BD%E6%95%B0.html" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-30T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"函数定义，函数实参形参，匿名函数，自执行函数，闭包","@type":"BlogPosting","url":"http://localhost:4000/2018/01/30/Js%E5%87%BD%E6%95%B0.html","headline":"JS函数","dateModified":"2018-01-30T00:00:00+08:00","datePublished":"2018-01-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/01/30/Js%E5%87%BD%E6%95%B0.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">JS函数</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-01-30T00:00:00+08:00" itemprop="datePublished">Jan 30, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>函数定义，函数实参形参，匿名函数，自执行函数，闭包
<!--break--></p>

<p>##Javascript函数</p>

<h4 id="1函数定义">1、函数定义</h4>

<p>定义函数有两种方式：</p>

<p>1、函数声明</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function sum(x,y){
  alert(x+y);
}
sum(1,2)
</code></pre></div></div>

<p>2、函数表达式</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var sum = function(x,y){
  alert(x + y)
}
sum(1,2);
</code></pre></div></div>

<p>3、函数提升
这两种定义之中只有函数声明会在代码执行之前有提升，即下列情况可以正常执行</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum(1,2)
function sum(x,y){
  alert(x+y);
}
</code></pre></div></div>

<h4 id="2匿名函数自执行函数">2、匿名函数、自执行函数</h4>

<p>函数表达式定义可以等价于  定义一个匿名函数 — 将匿名函数赋值给变量sum，执行的时候在变量名后面加上一对（），这其实是匿名函数的一种调用方法。
还有一种匿名函数的调用方法，用括号包裹表示函数声明表达这是一个函数表达式，后面的括号表示立即执行。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(function(){
  //块级作用域
})();
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function(){
  
}(); //这是错误的，因为function关键字是一个函数声明的开始，函数声明后面不能立即执行。
</code></pre></div></div>

<h4 id="3函数实参形参参数传值流程">3、函数实参形参，参数传值流程</h4>

<p><img src="http://localhost:4000/assets/参数.jpg" alt="参数.jpg" /></p>

<p>上图三种情况分别是：实参为数值、空、x三种情况，形参不为空且是x，arguments是每个函数都会有的Arguments对象的实例arguments，它引用着函数的实参。
参数传参流程：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1、实参会获取全局环境中的值，如第三块x获取全局定义var x =11;的值，第二块f( )调用获取了一个空值undefined；
2、实参值会传给函数申明中的形参x，值到括号里了，此时形参的值==实参的值；
3、形参x（亦局部变量）的值在函数体内通体有效，值到达函数体内部了，代码块中第一个console.log(x)都是反馈刚刚拿到的形参x的值;
4、函数内部变量x一律将形参x的值覆盖，给arguments[0]赋值，内部变量x的值也相应变化
</code></pre></div></div>

<h4 id="4函数调用">4、函数调用</h4>

<p>函数调用会免费赠送两个额外的参数：this和arguments。函数调用有四种方式：</p>

<p>1、方法调用</p>

<p>先定义一个对象，然后在对象的属性中定义方法，通过对象来调用方法。this指向object</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var object = {
  value:0,
  showValue:function(){
    alert(this.value);
  }
}
object.showValue();
</code></pre></div></div>

<p>2、函数调用 即函数定义之后的调用（函数声明和函数表达式两种），this指向全局变量</p>

<p>3、构造器调用</p>

<p>先定义一个函数对象，在对象中定义属性，在原型对象中定义方法。调用方法前先实例化函数对象，在进行调用。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var funcObject = function(name){
  this.name = name;
}
funcObject.prototype = {
  show:function(){
    alert(this.name);
  }
}
var newObject = new funcObject('huanhuan');
newObject.show();
</code></pre></div></div>

<p>4 、apply，call, bind调用</p>

<p>apply，call，bind都是函数对象的一个方法，作用是改变函数的调用对象。第一个参数是函数中this指向的对象。
a.call(b)	意思是仍然使用a的方法，只不过方法中的this指向b的。也可以说b继承了a的方法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var myobject={};
var sum = function(a,b){
　　return a+b;
};
var sum2 = sum.call(myobject,10,30); //var sum2 = sum.apply(myobject,[10,30]); 
alert(sum2);
</code></pre></div></div>

<p>call与apply的区别是apply接收的是数组参数。</p>

<p>同时我们知道，bind也可以改变this的指向。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>改变bar执行函数的this指向
var bar = function(){
console.log(this.x);
}
var foo = {
x:3
}
bar(); // undefined
var func = bar.bind(foo);
func(); // 3
</code></pre></div></div>

<p>那么，什么时候用bind，什么时候用apply，call呢？我们来个对比：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var obj = {
    x: 81,
};
 
var foo = {
    getX: function() {
        return this.x;
    }
}
 
console.log(foo.getX.bind(obj)());  //81
console.log(foo.getX.call(obj));    //81
console.log(foo.getX.apply(obj));	//81
</code></pre></div></div>

<p>三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。</p>

<p>也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p>

<h4 id="5闭包">5、闭包</h4>

<p>js闭包之前有文档记录过，可以去看。</p>

<p>####6、JS变量提升与函数提升</p>

<p>请注意变量赋值并没有被提升，只是声明被提升了</p>

<p><strong>1、变量提升</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var bar=1;
function test(){
  console.log(bar);     //undeifned
  var bar=2; 
  console.log(bar);  //2
}
test();
</code></pre></div></div>

<p>这就是JavaScript的变量提升，虽然变量bar的定义在后面，不过浏览器在解析的时候，
会把变量的定义放到最前面，相当于下面：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var bar=1;
function test(){
  var bar;
  console.log(bar);   //undefined
  bar=2; 
  console.log(bar);   //2
}
</code></pre></div></div>

<p>请注意变量赋值并没有被提升，只是声明被提升了。</p>

<p><strong>2、函数提升</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function test() {  
    foo(); // TypeError "foo is not a function"  
    bar(); // "this will run!"  
    var foo = function () { // 变量指向函数表达式  
        alert("this won't run!");  
    }  
    function bar() { // 函数声明 函数名为bar  
        alert("this will run!");  
    }  
}  
test();
</code></pre></div></div>

<p>函数提升和变量提升不同，函数体也会一同被提升。但是请注意，函数的声明有两种方式，只有函数式的声明才会连同函数体一起被提升。foo的声明会被提升，但是它指向的函数体只会在执行的时候才被赋值。</p>

<p><strong>3. eg</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a = 1;  
function b() {  
    a = 10;  
    return;  
    function a() {}  
}  
b();  
alert(a); 
</code></pre></div></div>

<p>相当于：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a = 1;  
function b() { 
	function a() {}  //相当于这里定义一个局部变量a
    a = 10;  
    return; 
    alert(a);     
}  
b();  
alert(a); 
</code></pre></div></div>

<p>现在可以看到局部变量的a是10，外部的是1；</p>

<p><strong>4.作用域</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var x = 1;  
if (x) {  
    var x = 2;  
    console.log(x); // 2  
}  
console.log(x); // 2
</code></pre></div></div>

<p>因为javascript是函数作用域。这是和c家族语言最大的不同。该程序里面的if并不会创建新的作用域
为了实现本来的结果，我们使用闭包来解决。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var x = 1;  
if (x) {  
    (function () {  
        var x = 2;
        console.log(x); // 2    
    }());  
}
console.log(x); // 1
</code></pre></div></div>

<h4 id="7回调函数">7、回调函数</h4>

<p>一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。</p>

<p>#####1.eg1</p>

<p>function a(callback) {
    callback();
}</p>

<p>function b() {
    console.log(‘hello callback’);
}</p>

<p>a(b);</p>

<p>#####2.eg2</p>

<p>function print(){
	console.log(‘callback’);
}
setTimeout(print,1000);</p>


  </div><a class="u-url" href="/2018/01/30/Js%E5%87%BD%E6%95%B0.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
