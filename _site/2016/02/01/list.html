<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<link rel="stylesheet" href="/styles/css/index.css">
		<title>list</title>
　　</head>
　　<body>
　　　　	<div class="container">
	<div class="left">
		<div class="content">
			<div class="logo">
				<img src="/../assets/logo.jpg" alt="logo">
			</div>
			<div class="motto">依你之萍</div>
			<div class="navigation">
				<span class="btn pink">
					<a href="http://localhost:4000">
						<img src="/../assets/home.png" alt="home">
					</a>
				</span>
				<span class="btn white">
					<a href="http://weibo.com/u/2627764953" target="_blank">
						<img src="/../assets/weibo.png" alt="weibo">
					</a>
				</span>
				<span class="btn pink">
					<a href="https://github.com/winnieping" target="_blank">
						<img src="/../assets/github.png" alt="github">
					</a>
				</span>
				<span class="btn white">
					<a href="/2016/02/01/list.html">
						<img src="/../assets/note.png" alt="note">
					</a>
				</span>
			</div>
		</div>
	</div>
	<div class="right">
		<div class="index-box list-box">
	<ul>
		
			
	　　　　	<li>
				<div class="title">Js算法</div>
				<div class="date">2018-07-30</div>
				<div class="content">这里收集一些JS常用的算法

#### 一、算法复杂度

算法复杂度分为时间复杂度和空间复杂度。

时间复杂度：执行算法所需的时间

```
T(n)=O(f(n))
T(n):一个算法中的语句执行次数
一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))
时间复杂度中：O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶
```

```
计算时间复杂度的方法：
1、用常数1代替运行时间中的所有加法常数
2、修改后的运行次数函数中，只保留最高阶项
3、去除最高阶项的系数
```

1、常数阶：

```
int sum = 0,n = 100; //执行一次  
sum = (1+n)*n/2; //执行一次  
System.out.println (sum); //执行一次 
所以 f(n)=3，由第一条知时间复杂度为O(1)。
```

2、线性阶

```
for(int i=0;i&lt;n;i++){
//时间复杂度为O(1)的算法
...
}
上面算法循环体中的代码执行了n次，因此时间复杂度为O(n)
```

3、对数阶

```
int number=1;
while(number&lt;n){
number=number*2;
//时间复杂度为O(1)的算法
...
}
可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)
```

4、平方阶

循环嵌套

```
for(int i=0;i&lt;n;i++){   
      for(int j=0;j&lt;n;i++){
         //复杂度为O(1)的算法
         ... 
      }
  }
  线性阶时就已经得知是O(n)，现在经过外层循环n次，那么这段算法的时间复杂度则为O(n²)
```



空间复杂度：执行算法所需存储空间



#### 二、排序算法

##### 1、冒泡排序

js实现冒泡排序

```
function bubbleSort(data){
    for(var i=0;i&lt;data.length;i++){
        for(var j=0;j&lt;data.length -i -1;j++){
            if(data[j] &lt; data[j+1]){
            	var temp;
                temp = data[j];
                data[j] = data[j+1];
                data[j+1] = temp;
            }
        }
    }
}
var arr = [45, 32, 8, 33, 12, 22, 19, 97];
bubbleSort(arr);
```

冒泡排序原理

1、比较相邻的元素，如果第一个比第二个大，就交换他们。

2、对每一对相邻元素都做这个操作，从第一对到最后一对，那么最后一个元素是最大值。

3、重复以上步骤，对数组进行排序，但是最后一个不需要排序了。

4、直到数组越来越少，需要排序的相邻元素都没有就结束。

冒泡排序的时间复杂度 o(n*n)

##### 2、快速排序

```
function quickSort(arr){
    //如果数组&lt;=1,则直接返回
    if(arr.length&lt;=1){return arr;}
    var pivotIndex=Math.floor(arr.length/2);
    //找基准，并把基准从原数组删除
    var pivot=arr.splice(pivotIndex,1)[0];
    //定义左右数组
    var left=[];
    var right=[];

    //比基准小的放在left，比基准大的放在right
    for(var i=0;i&lt;arr.length;i++){
         if(arr[i]&lt;=pivot){
                left.push(arr[i]);
         }else{
                right.push(arr[i]);
         }
    }
    //递归
    return quickSort(left).concat([pivot],quickSort(right));
 }
```

</div>
				<a href="/2018/07/30/JS%E7%AE%97%E6%B3%95.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Js事件流</div>
				<div class="date">2018-07-06</div>
				<div class="content">##### 1、JS事件绑定

如何像DOM元素添加事件？通常有三种方法

1. 在dom元素中绑定
2. 在js中绑定
3. 绑定监听事件函数

1、onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup

```
<input type="button" value="click me" onclick="hello()" />
 
<script>
    function hello(){
     	alert("hello world!");
    }
</script>
```

2、

```
<input type="button" value="click me" id="btn" />
 
<script>
    document.getElementById("btn").onclick = function(){
     	alert("hello world!");
    }
</script>
```



3、用 addEventListener() 或 attachEvent() 来绑定事件监听函数。

*element*.addEventListener(*event*, *function*, *useCapture*)

event：指定事件名

function：事件触发执行函数

useCapture：指定事件流的的方向

事件监听的优点：

1. 常规的事件绑定只执行最后绑定的事件。事件监听可以绑定多个事件。
2. 可以解除事件绑定

##### 2、JS事件流

**事件流分为事件冒泡和事件捕获**

当点击事件发生的时候，我们并不认为只有当前节点被点击，而是他的父节点，整个页面也被点击了。

ie和Netscape开发团队提出了两种事件流的概念。

ie的叫做事件冒泡，事件从最具体的元素接收，然后逐级向上传播。

netScape的叫做事件捕获，事件从最不具体的元素先接收，然后逐级向下传播，直到最具体的元素接收。

- egHTMl：1.事件冒泡-事件捕获.html

##### 3、事件委托（也叫事件代理）

把一个元素的事件委托到另一个元素上

原理：利用事件冒泡原理实现，事件从最深的节点开始，逐步向上传播事件，指定较外层节点处理事件。

好处：

1. 节省内存空间，不需要绑定很多对象，只绑定一个父对象就可以。
2. 提高Javascript性能
3. 可以为新添加的Dom元素动态添加事件

手写一个事件委托

```
???????????
```

##### 

##### 4、阻止事件冒泡和默认事件

阻止冒泡

```
event.stopPropagation();
```

阻止默认事件

```
event.preventDefault();
```



##### 5、js事件循环机制

js是单线程非阻塞的脚本语言。那么单线程语言如何实现事件循环机制的呢？？

单线程：

浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性

非阻塞：

按道理js单线程应该是阻塞的，javascript引擎到底是如何实现的非阻塞这一点呢？

js本身不可能异步，但是js的宿主环境是多线程的，宿主通过event loop（事件循环）让js拥有了异步的能力。

**事件循环**

由于大多数现代系统内核是多线程的、同理浏览器内核也是多线程的，内核可以处理后台执行的多个操作。当其中一个操作完成的时候，内核告诉 Node.js，相应的回调就被添加到轮询队列（poll queue）并最终得到执行。

所有的事件被分为两种，同步任务-执行栈中、异步任务-事件队列中、

***执行栈与事件队列***

* 执行栈：

我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。

当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。

* 事件队列：（事件队列中的函数执行是浏览器开辟的新线程执行的）

js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。

* macro task与micro task

异步任务的优先级不同，因此也有分为宏任务和微任务

以下事件属于宏任务：

- `setInterval()`
- `setTimeout()`

以下事件属于微任务

- `new Promise()`
- `new MutaionObserver()`

在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。

```
setTimeout(function () {
    console.log(1);
});

new Promise(function(resolve,reject){
    console.log(2)
    resolve(3)
}).then(function(val){
    console.log(val);
})
结果是什么呢？
231
```

我们上面讲的是js的event loop，nodeJs的事件循环则稍有不同，会有一些不确定性。

</div>
				<a href="/2018/07/06/Js%E4%BA%8B%E4%BB%B6%E6%B5%81.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Js原生dom操作</div>
				<div class="date">2018-07-06</div>
				<div class="content">##### 1. 节点

DOM节点，也叫DOM Node。

根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点。

- 整个文档是一个文档节点

- 每个 HTML 元素是元素节点

- HTML 元素内的文本是文本节点

- 每个 HTML 属性是属性节点

- 注释是注释节点

  所以HTML节点类型一共有5种。文档节点、元素节点、文本节点、属性节点、注释节点

##### 2. 创建节点

创建元素节点、创建文本节点、创建文档碎片、克隆节点

createElement、createTextNode、createDocumentFragment、cloneNode

```
var a = document.createElement("标签名");
var node = document.createTextNode("我是文本节点");
var m = a.cloneNode(true);
node.cloneNode(true/false) ，它接收一个bool参数，用来表示是否复制子元素。
```



##### 3.节点之间的关系

var a = document.getElementById("id1");

父节点 	 a.parentNode

子节点 	a.childNodes

兄弟节点		a.nextSibling		a.previousSibling

##### 4.节点的操作

为元素添加自己的属性

```
a.id = “myDiv”；
a.className = "myDivClass";
```

节点添加、删除、替换

```

parent.appendChild(child);
如：document.body.appendChild(a);
parentNode.insertBefore(newNode, refNode);
如：
var deletedChild = parent.removeChild(node);
parent.replaceChild(newChild, oldChild);
```



##### 5.节点查找

`getElementById()`			方法可返回对拥有指定 ID 的第一个对象的引用。
`getElementsByClassName() `	方法可以返回所有指定类名的对象的集合。。
`getElementsByTagName()`		方法可返回带有指定标签名的对象的集合。
`getElementsByName() `		方法可返回带有指定名称的对象的集合。
`querySelector() `		方法返回文档中匹配指定 CSS 选择器的一个元素。
`querySelectorAll()`			方法返回匹配所有指定选择器的元素。

```
<div class="div">A</div>
<ul id="ul">
    <li class="li">B</li>
    <li class="li">C</li>
</ul>
<span>D</span>
<input name="name" type="button" />

document.getElementById("ul");
document.getElementsByClassName('div');
document.getElementsByTagName('span');
document.getElementsByName('name');
document.querySelector(".div")
document.querySelectorAll(".div ,#ul")
```



##### 6.属性节点操作

`setAttribute()`添加一个新属性（`attribute`）到元素上，或改变元素上已经存在的属性的值。如果这个指定的属性已存在，则仅设置/更改值。

`removeAttribute()`该方法用于移除元素的属性。

```
//添加属性
var div = document.getElementById("div");
div.setAttribute("class", "new_class");
div.setAttribute("id", "new_id");

//移除属性
var div2 = document.getElementById("div2");
div2.removeAttribute("class");
```



##### 7.节点添加事件

`addEventListener()`将指定的事件监听器注册到目标对象上，当目标对象触发制定的事件时，指定的回调函数就会触发。目标对象可以是 文档上的元素、 document、 window 或者XMLHttpRequest(比如onreadystatechange事件)。

```
var div = document.getElementById("div");
div.addEventListener("click", function(){
      alert('嘻嘻');
},false);
```

</div>
				<a href="/2018/07/06/JS%E5%8E%9F%E7%94%9FDom%E6%93%8D%E4%BD%9C.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">浏览器兼容性问题汇总</div>
				<div class="date">2018-07-05</div>
				<div class="content">自己在工作中遇到的兼容性问题

一、input type=number

二、日期格式</div>
				<a href="/2018/07/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Html</div>
				<div class="date">2018-07-05</div>
				<div class="content">#### 一、HTML5带来的特性

2014年，html5.0版本终于发布，距离上一个版本1999年制定的html4已经有十几年的时间，html5为我们带来了很多前所未有的新特性。

1、语义化

H5增加了新标签，header、nav、article、aside、footer、section

优点：给网页更好的结构和意义，对搜索引擎更友好。特别是新闻类，博客类网站受益很大。

缺点：使用新特性，如何兼容不支持的浏览器。（IE11支持，其他浏览器大部分支持）

2、本地存储特性

本地存储历史

cookie（最早、4kb）-&gt;然后是H5的 localStorage、sessionStorage

getItem()、setItem()、removeItem()

***注意：H5本地存储只存储字符串，所以需要自己进行类型转换。

3、设备访问特性

地理位置API、媒体访问API

4、连接特性

5、网页多媒体特性

audio 和 video标签

6、三维、图形及特效特性

#### 二、标准模式与怪异模式

浏览器对html和css的解析有两种模式，标准模式和怪异模式。

浏览器会根据html的文档类型声明来决定使用哪一种模式。(文档类型声明说明html的版本)

```
Html5

&lt;!DOCTYPE html&gt;


Html4.01

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd"&gt;
```

两种模式的常见区别

盒模型的处理差异

标准模式会使用标准盒模型来渲染，怪异模式会使用怪异盒模型（ie盒模型）来渲染。

行内元素的垂直对齐

标准模式的会对齐基线，怪异模式会对齐底部。

#### 三、XMl、HTML与XHTML的区别

xml：被设计来传输和存储数据

html：被设计来展示数据

xhtml：两者的过度语言，相对于html，要求更为严格。

html是超文本标记语言，xhtml是可扩展超文本标记语言。

#### 四、data-的好处

Html5的新特性之一。用户可以使用data-来定义一些数据存储到标签里。避免用户自定义属性来存储和操作数据。

```
<div data-myname="xiaowang" id="testDiv">xiao</div>

console.log("data-myname:",document.getElementById("testDiv").dataset.myname);
console.log("data-myname:",document.getElementById("testDiv").getAttribute("data-myname"));
```

#### 五、meta标签

标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。

典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。

元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。

一般的meta标签

```
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,shrink-to-fit=no,minimum-scale=1,maximum-scale=1,minimal-ui" />
<meta name="theme-color" content="#000000" />
<meta name="full-screen" content="yes" />
```



```
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=Edge" />
<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=0.25" />
```

常用的比如1、设置编码格式，那么浏览器在请求html的时候，服务器会在http头上带有

Content-Type: text/html; charset=UTF-8

2、设置http-equiv，它把content属性关联到http 头

那么设置<meta http-equiv="X-UA-Compatible" content="IE=edge" />

则http头上带有X-Ua-Compatible: IE=Edge,chrome=1 （参考百度的网站）

X-UA-Compatible字段是用来定义浏览器的渲染方式，比如：使用IE内核浏览器来访问，会渲染至该浏览器的最高版本，比如你使用IE9浏览器，那么就算在兼容模式切换至IE7，但仍会渲染成IE9的样子。

3、设置name，把content属性关联到一个名词

比如设置：<meta name="renderer" content="webkit" />

设置renderer：webkit，由于国内部分浏览器是双核浏览器，一个是快速渲染的webkit内核，一个是ie内核。

####六、浏览器内核

浏览器内核也称“渲染引擎”，用来解释网页语法并渲染到网页上。
浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。

五大浏览器：

IE ------IE内核（Trident内核）

Firefox ——— Gecko内核

Google Chrome ------ Webkit内核 ❌ 现在是 Blink内核

Safari ------ Webkit内核

Opera ------Presto内核

其他浏览器：大部分是双内核

IE内核和webkit内核

####七、

</div>
				<a href="/2018/07/05/html.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">面试题</div>
				<div class="date">2018-05-03</div>
				<div class="content">####  1、如何解决0.1+0.2= 0.30000000000000004

```
js中浮点数采用IEEE 754标准的双精度浮点数表示。
数字在转换成二进制的时候，会有不能整除的情况，根据精度（双精度浮点数)取64位有效值。再转化为十进制就是0.3000……4.
解决方法：toFixed
let a = 0.11,b = 0.2801,d = 1.002;
let c = a + b + d;
let e = c.toFixed(4);
parseFloat(c.toFixed(10))
```

#### 2、实现一个数结构的菜单

2.1递归调用
以**斐波那契数列**为例

```
var Fibonacci = function(n){   
	if(n &lt;= 2){
    	return 1
     }else{
         return Fibonacci(n - 1) + Fibonacci(n - 2);
     }
}
let x = Fibonacci(10);
console.log("Fibonacci",x)
```

2.2

树结构菜单实现

参考treeMenu文件夹

#### 3、设计如下一个场景

10个ajax同时发起，全部响应后展示所有返回结果，如果最多容忍3个http请求失败。

#### 4、如何实现 a==1&amp;&amp;a==2

```
const a = { i: 1, toString: function () { return a.i++; }};
console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3);
```

这里讲的是js的隐式转换，当a为对象时，js会调用toString方法，我们修改了toString方法，每次运行完a会加一，所以等式成立。

隐士转换：	对象 -字符串 -数字

​			布尔-数字</div>
				<a href="/2018/05/03/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">知识点汇总</div>
				<div class="date">2018-03-28</div>
				<div class="content">面试大总结
</div>
				<a href="/2018/03/28/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E6%A6%82%E8%A6%81.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">DataStructure</div>
				<div class="date">2018-03-28</div>
				<div class="content">数据结构主要有数组、链表、哈希、
</div>
				<a href="/2018/03/28/DataStructure.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">浏览器的工作原理</div>
				<div class="date">2018-03-26</div>
				<div class="content">浏览器的工作原理
</div>
				<a href="/2018/03/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">模块化编程</div>
				<div class="date">2018-03-23</div>
				<div class="content">随着应用越来越复杂，js必然走向模块化编程。如何模块化编程呢？
</div>
				<a href="/2018/03/23/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">网页编码</div>
				<div class="date">2018-03-22</div>
				<div class="content">网页在传输数据的过程中资源会被编码压缩，然后通过http头注明相应参数，浏览器收到后进行解压解码，实现正常显示。
比如我们常常看到Content-Type：application/json，charset = UTF-8 || Content-Type: text/html || Content-Type: image/png （在内容格式中注明编码格式）
比较常见的编码格式还有 GBK、GB2312

##### 一、讲一个故事

很久很久以前，有一群人美国人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物，他们把这称为”字节”。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去，他们就把这机器称为”计算机”。
**注意8个开合的晶体管一共有2的8次方 = 256种状态**

1、美国人把控制码和大小写字母，数字，空格，标点符号分别用1-127号状态来表示，这就是 **ANSI** 的”**Ascii**”编码。

2、后来计算机发展越来越快，世界各国为了保存他们的文字，他们决定采用127后的状态码来表示这些新的字母、符号，一直用到了最后一个状态255，从128-255的字符集被称为**扩展字符集**。

3、等到中国人得到计算机时，已经没有可以利用的字节状态来表示汉字了，而且我们有6000多常用汉字需要保存。于是中国人把127号以后的符号全部取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。
**这种汉字方案叫做** “GB2312″。**GB2312** 是对 **ASCII** 的中文扩展。

4、但是中国的汉字太多了，后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是 扩展字符集里的内容。结果扩展之后的编码方案被称为 **GBK** 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。

5、后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，**GBK** 扩成了 **GB18030**。

6、由于当时各国都有一套自己的编码标准，谁也不支持谁的编码，于是有一个ISO的国际化组织决定解决这个问题，他们废掉所有的地区性编码，重做一套包括地球上所有文化、所有字母和符号的编码。这个就叫做**UNICODE**。
UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于 ascii 里的那些”半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。

7、UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，**UTF8** 就是每次8个位传输数据，而** UTF16** 就是每次16个位，只不过为了传输时的可靠性，从UNICODE到 UTF时并不是直接的对应，而是要过一些算法和规则来转换。

##### 二、课代表：

- 中国人民通过对 ASCII 编码的中文扩充改造，产生了 GB2312 编码，可以表示6000多个常用汉字。
- 汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。
- 中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码。
- 每个国家都像中国一样，把自己的语言编码，于是出现了各种各样的编码，如果你不安装相应的编码，就无法解释相应编码想表达的内容。
- 终于，有个叫 ISO 的组织看不下去了。他们一起创造了一种编码 UNICODE ，这种编码非常大，大到可以容纳世界上任何一个文字和标志。所以只要电脑上有 UNICODE 这种编码系统，无论是全球哪种文字，只需要保存文件的时候，保存成 UNICODE 编码就可以被其他电脑正常解释。
- UNICODE 在网络传输中，出现了两个标准 UTF-8 和 UTF-16，分别每次传输 8个位和 16个位。
  于是就会有人产生疑问，UTF-8 既然能保存那么多文字、符号，为什么国内还有这么多使用 GBK 等编码的人？因为 UTF-8 等编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 等编码也可以。但是目前的电脑来看，硬盘都是白菜价，电脑性能也已经足够无视这点性能的消耗了。所以推荐所有的网页使用统一编码：**UTF-8**。



</div>
				<a href="/2018/03/22/%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A0%81.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Js OOP</div>
				<div class="date">2018-02-06</div>
				<div class="content">Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。
</div>
				<a href="/2018/02/06/jsOOP.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Css 布局</div>
				<div class="date">2018-02-04</div>
				<div class="content">html文档的正常文档流应该是所有块级元素从上往下依次排列，所有行内元素沿着行间排列。css可以改变这种布局得到我们想要的布局样式。
</div>
				<a href="/2018/02/04/css.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">JS函数</div>
				<div class="date">2018-01-30</div>
				<div class="content">函数定义，函数实参形参，匿名函数，自执行函数，闭包
</div>
				<a href="/2018/01/30/Js%E5%87%BD%E6%95%B0.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">javascript获取浏览器基本信息</div>
				<div class="date">2017-12-26</div>
				<div class="content"></div>
				<a href="/2017/12/26/%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">bug逻辑</div>
				<div class="date">2017-12-03</div>
				<div class="content">修改bug遇到的吐血集锦

</div>
				<a href="/2017/12/03/bug%E9%80%BB%E8%BE%91.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">回调函数</div>
				<div class="date">2017-05-10</div>
				<div class="content">一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。 
</div>
				<a href="/2017/05/10/callback.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">BFC</div>
				<div class="date">2017-05-08</div>
				<div class="content">block formatting context:块级格式化上下文
</div>
				<a href="/2017/05/08/BFC.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">es6</div>
				<div class="date">2017-05-05</div>
				<div class="content">关于es6的一些新特性

</div>
				<a href="/2017/05/05/es6.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">JS变量、函数提升与作用域</div>
				<div class="date">2017-03-30</div>
				<div class="content">请注意变量赋值并没有被提升，只是声明被提升了。
</div>
				<a href="/2017/03/30/scope.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">ValueCopy</div>
				<div class="date">2017-03-29</div>
				<div class="content">ECMAScript变量的值类型有两种，基本类型和引用类型.
</div>
				<a href="/2017/03/29/valuecopy.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">webpack（打包）</div>
				<div class="date">2017-03-28</div>
				<div class="content">webpacke多入口情况，我们把第三方库，和组件，还有css分开来打包。 
</div>
				<a href="/2017/03/28/webpack.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Javascript关键字</div>
				<div class="date">2017-03-27</div>
				<div class="content">this关键字，在全局范围，函数调用，构造函数，对象方法中指向各不相同，我们还可以手动改变this指向。
</div>
				<a href="/2017/03/27/%E5%85%B3%E9%94%AE%E5%AD%97.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">JavaScript数据类型</div>
				<div class="date">2017-03-26</div>
				<div class="content">关于Javascript的数据类型、变量定义、隐式转换
</div>
				<a href="/2017/03/26/Js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">继承（inherit）</div>
				<div class="date">2017-03-24</div>
				<div class="content">Javascript如何实现继承?
</div>
				<a href="/2017/03/24/inherit.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">原型和原型链</div>
				<div class="date">2017-03-23</div>
				<div class="content">实例与原型的链条，就是让一个实例继承所有的对象
</div>
				<a href="/2017/03/23/prototype.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">文件上传</div>
				<div class="date">2017-03-15</div>
				<div class="content">采用百度团队开发的webuploader + express部署服务器。
</div>
				<a href="/2017/03/15/upload.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Ajax介绍（下）</div>
				<div class="date">2017-03-14</div>
				<div class="content">废话不多说，上代码
</div>
				<a href="/2017/03/14/ajax2.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Ajax</div>
				<div class="date">2017-03-14</div>
				<div class="content">Ajax：A（异步）的 JA（javascript）和 X（xml）。实现 客户端异步请求操作，从而实现不用刷新页面的情况下与服务器通信，减少用户等待时间，提高用户体验。
</div>
				<a href="/2017/03/14/ajax.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">cookie和session</div>
				<div class="date">2017-03-12</div>
				<div class="content">目前还没做过cookie缓存
</div>
				<a href="/2017/03/12/cookies-webstorage.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Sass</div>
				<div class="date">2017-03-11</div>
				<div class="content">完全兼容 CSS3  
sass是一款css预处理语言。
在 CSS 语言基础上添加了扩展功能，比如变量、嵌套 (nesting)、混合 (mixin)  
对颜色和其它值进行操作的{Sass::Script::Functions 函数}  
</div>
				<a href="/2017/03/11/sass.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">js几种常见设计模式</div>
				<div class="date">2017-03-10</div>
				<div class="content">Javascript的设计模式,在平时我们接触的很多代码里已经包含了一些设计模式的实现,在这里做个概念性介绍。
</div>
				<a href="/2017/03/10/Js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">React2</div>
				<div class="date">2017-03-09</div>
				<div class="content">React并不是一个MVC框架，只是一个用于构建UI的javascript库。  React一般也叫React.js，起源于facebook，提倡用可重用的组件来表现随时间变化的数据。
</div>
				<a href="/2017/03/09/react2.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">React</div>
				<div class="date">2017-03-09</div>
				<div class="content">React并不是一个MVC框架，只是一个用于构建UI的javascript库。  React一般也叫React.js，起源于facebook，提倡用可重用的组件来表现随时间变化的数据。
</div>
				<a href="/2017/03/09/react.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">gulp</div>
				<div class="date">2017-03-08</div>
				<div class="content">gulp是一个nodejs的streaming构建工具，所谓的streaming大致意思就是把构建流程想成一个个链接的管道。
</div>
				<a href="/2017/03/08/gulp.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">网页性能初体验(Performance)</div>
				<div class="date">2017-03-07</div>
				<div class="content">网页性能可以从多方面，多维度来评估。
</div>
				<a href="/2017/03/07/performance.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Javascript闭包（Closure）</div>
				<div class="date">2017-03-07</div>
				<div class="content">js的作用域只有两种，全局作用域和方法作用域，不存在块级作用域。
</div>
				<a href="/2017/03/07/JsClosure.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">正则表达式(RegExp）</div>
				<div class="date">2017-03-03</div>
				<div class="content">正则表达式：regular expression   
</div>
				<a href="/2017/03/03/regexp.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">跨域（cors）</div>
				<div class="date">2017-03-01</div>
				<div class="content">跨域的原理，就是受同源策略（域名，协议，端口）的影响，本域的js不能操作其它域的页面对象。 
</div>
				<a href="/2017/03/01/cors.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">响应式布局</div>
				<div class="date">2016-02-28</div>
				<div class="content">响应式布局的概念是为了让网页在不同分辨率的屏幕上都有较好的展示效果，即需要应用不同的css样式。
</div>
				<a href="/2016/02/28/respond.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">NRM</div>
				<div class="date">2016-02-13</div>
				<div class="content">提升下载速度,避免总是安装错误的包
</div>
				<a href="/2016/02/13/nrm.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
	　　　　	<li>
				<div class="title">Git使用笔记</div>
				<div class="date">2016-02-12</div>
				<div class="content">分布式版本管理系统，为了更好地管理Linux内核开发而创立。
</div>
				<a href="/2016/02/12/git.html">阅读全文 &gt;&gt;</a>
			</li>
			
　　　　
			
　　　　
	</ul>
</div>

	</div>
</div>


　　</body>
</html>
