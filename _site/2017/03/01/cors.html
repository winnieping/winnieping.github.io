<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<link rel="stylesheet" href="/styles/css/index.css">
		<title>跨域（cors）</title>
　　</head>
　　<body>
　　　　	<div class="container">
	<div class="left">
		<div class="content">
			<div class="logo">
				<img src="/../assets/logo.jpg" alt="logo">
			</div>
			<div class="motto">依你之萍</div>
			<div class="navigation">
				<span class="btn pink">
					<a href="http://localhost:4000">
						<img src="/../assets/home.png" alt="home">
					</a>
				</span>
				<span class="btn white">
					<a href="http://weibo.com/u/2627764953" target="_blank">
						<img src="/../assets/weibo.png" alt="weibo">
					</a>
				</span>
				<span class="btn pink">
					<a href="https://github.com/winnieping" target="_blank">
						<img src="/../assets/github.png" alt="github">
					</a>
				</span>
				<span class="btn white">
					<a href="/2016/02/01/list.html">
						<img src="/../assets/note.png" alt="note">
					</a>
				</span>
			</div>
		</div>
	</div>
	<div class="right">
		<p>跨域的原理，就是受同源策略（域名，协议，端口）的影响，本域的js不能操作其它域的页面对象。 
<!--break--></p>
<h1 id="跨域资源共享cors">跨域资源共享（cors)</h1>

<h3 id="1概述">1、概述</h3>
<p>当一个资源请求一个其他域名或者端口的资源时，会产生跨域http请求。<br />
浏览器会限制脚本发起跨域请求，这是对网站资源的保护。<br />
所以我们需要跨域资源共享规范。即cors（Cross-origin resource sharing）</p>

<h3 id="2两种请求">2、两种请求</h3>
<p>跨域将请求分为两种：简单请求 + 非简单请求</p>
<h3 id="21-简单请求">2.1 简单请求</h3>
<p>简单请求处理：浏览器直接发出跨域共享请求–》在头信息中，增加origin字段，说明请求来源
请求字段：<br />
origin：<br />
说明请求来源<br />
服务器返回字段：<br />
Access-Control-Allow-Origin：<br />
值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求<br />
Access-Control-Allow-Credentials：<br />
是否允许发送Cookie，true or false <br />
Access-Control-Expose-Headers：<br />
允许访问的服务器的头信息的白名单</p>
<h3 id="22-非简单请求">2.2 非简单请求</h3>
<p>非简单请求处理：浏览器先发出预检请求，预检请求带OPTIONS，表达这个请求是询问的。<br />
预检请求字段：
Access-Control-Request-Method：<br />
列出浏览器的CORS请求会用到哪些HTTP方法，<br />
Access-Control-Request-Headers：<br />
列出浏览器CORS请求会额外发送的头信息字段，<br />
服务器返回字段：<br />
Access-Control-Allow-Methods：<br />
表示服务器支持的所有跨域请求的方法<br />
Access-Control-Allow-Headers：<br />
表示服务器支持的所有头信息字段<br />
Access-Control-Max-Age：<br />
指定本次预检请求的有效期，单位为秒，在此期间，不用发出另一条预检请求<br />
预检请求通过，则会继续发出和简单请求一样的http请求。<br />
预检请求未通过，请求失败</p>
<h3 id="23-带凭证信息的请求">2.3 带凭证信息的请求</h3>
<p>在简单请求中，有是否发送HTTP Cookies和验证信息功能。  <br />
请求字段：<br />
withCredentials：ture  <br />
允许凭证信息一起发送<br />
服务器返回字段：<br />
Access-Control-Allow-Credentials: true<br />
<strong>**<em>特别注意<br />
Access-Control-Allow-Origin<br />
不能为</em></strong>*，需要设置为该请求网页一致的域名。</p>
<h3 id="跨域的原理就是受同源策略域名协议端口的影响本域的js不能操作其它域的页面对象然后我们就要解决这个问题">跨域的原理，就是受同源策略（域名，协议，端口）的影响，本域的js不能操作其它域的页面对象，然后我们就要解决这个问题。</h3>
<h1 id="解决跨域方法之-服务器代理跨域-nodejs跨域">解决跨域方法之 服务器代理跨域 NODEJS跨域</h1>
<p>服务器不受同源策略影响</p>
<h3 id="1创建express应用程序">1.创建express应用程序</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var express = require('express');  
var app = express();
</code></pre></div></div>
<h3 id="2设置跨域访问相应标头">2.设置跨域访问相应标头</h3>
<p>通过all方法设置所有请求都需要的头信息</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>app.all('*', function(req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With");
    res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
    res.header("X-Powered-By", ' 3.2.1')
    res.header("Content-Type", "application/json;charset=utf-8");
}
</code></pre></div></div>
<h3 id="3发送请求">3.发送请求</h3>
<p>采取nodejs request模拟浏览器发起请求</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>app.all('*', function(req, res, next) {
	option = {
	    url: 'http://KKKK' + req.originalUrl,
	    method: req.method,
	    json: true,
	    body: req.body,
	    headers: {
	        "content-type": "application/json"
	    }
	};
	request(option, function(error, response, body) {
		if (!error &amp;&amp; response.statusCode == 200) {
	        res.send(body);
	    }
	}
}

</code></pre></div></div>
<h3 id="4监听8081端口将8081端口的请求发送到-httpkkkk">4.监听8081端口，将8081端口的请求发送到 http://KKKK</h3>
<p>app.listen(8081);</p>

<h1 id="解决跨域方法之-jsonp-学习">解决跨域方法之 JSONP 学习</h1>
<h3 id="1概述-1">1.概述</h3>
<p>json：轻量级的数据交换格式<br />
jsonp：一种使用JSON数据的方式</p>
<h3 id="2jsonp-原理">2.JSONP 原理</h3>
<p>HTTP请求虽然受跨域限制，但是Web页面上调用js文件时则不受是否跨域的影响，而且拥有”src”这个属性的标签都拥有跨域的能力。比如
 &lt;’script’&gt;、&lt;’img’&gt;、&lt;’iframe’&gt;</p>

<p>于是乎？
如果要进行跨域请求，通过使用html的script标记来进行跨域请求，并在响应中返回要执行的script代码<br />
即在跨域的服务端生成JSON数据，然后包装成script脚本回传，就突破同源策略的限制，实现跨域！
动态创建一个script标签，设置src，将script作为参数返回调用。<br />
客户端代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>script type="text/javascript"  
    $.ajax({  
        url:"http://crossdomain.com/services.php",  
        dataType:'jsonp',  
        data:'',  
        jsonp:'callback',  
        success:function(result) {  
            for(var i in result) {  
                alert(i+":"+result[i]);//循环输出a:1,b:2,etc.  
            }  
        },  
        timeout:3000  
    });  
/script

</code></pre></div></div>

<p>var a = 1;
console.log(a++);
console.log(++a);</p>

<h1 id="解决跨域方法之-nginx-实现跨域">解决跨域方法之 nginx 实现跨域</h1>
<h3 id="1概述-2">1、概述</h3>
<p>nginx 类似于tomcat，可以进行HTTP服务处理，主要作为反向代理服务器使用，Wordpress、GitHub等知名的网站都使用到了Nginx。在这里我们使用nginx作为正向代理。</p>
<h4 id="2反向代理-vs-正向代理">2、反向代理 VS 正向代理</h4>
<p>正向代理：架设在客户机与目标主机之间，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。
反向代理：设在服务器端，此时代理服务器与目标主机一起对外表现为一个服务器。
正向代理代理的对象是客户端，反向代理代理的对象是服务端。</p>
<h4 id="3使用">3、使用</h4>
<p>安装nginx，修改配置文件</p>
<blockquote>
  <p>进入nginx目录，cd /usr/local/etc/nginx/<br />
进入conf文件，sudo vim /usr/local/etc/nginx/nginx.conf 
修改文件如下</p>
</blockquote>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
            listen       9999;
            server_name  localhost;


        location /autho-dev/ {
            add_header 'Access-Control-Allow-Origin' 'http://localhost:8080' always;
            add_header 'Access-Control-Allow-Credentials' 'true' always;
            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
            add_header 'Access-Control-Allow-Headers' 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With' always;

            if ($request_method = OPTIONS ) {
                return 200;
            }

    #       proxy_pass http://autho.chiq-cloud.com;
            proxy_pass http://10.4.32.70:8080;
        }
    }
</code></pre></div></div>

<p>然后重启nginx<br />
sido nginx -s reload</p>

<h4 id="4nginx命令">4、nginx命令：</h4>
<p>启动nginx：sido nginx<br />
关闭nginx：查找当前nginx进程号，然后输入命令：kill -HUP 进程号</p>


	</div>
</div>


　　</body>
</html>
