<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<link rel="stylesheet" href="/styles/css/index.css">
		<title>继承（inherit）</title>
　　</head>
　　<body>
　　　　	<div class="container">
	<div class="left">
		<div class="content">
			<div class="logo">
				<img src="/../assets/logo.jpg" alt="logo">
			</div>
			<div class="motto">依你之萍</div>
			<div class="navigation">
				<span class="btn pink">
					<a href="http://localhost:4000">
						<img src="/../assets/home.png" alt="home">
					</a>
				</span>
				<span class="btn white">
					<a href="http://weibo.com/u/2627764953" target="_blank">
						<img src="/../assets/weibo.png" alt="weibo">
					</a>
				</span>
				<span class="btn pink">
					<a href="https://github.com/winnieping" target="_blank">
						<img src="/../assets/github.png" alt="github">
					</a>
				</span>
				<span class="btn white">
					<a href="/2016/02/01/list.html">
						<img src="/../assets/note.png" alt="note">
					</a>
				</span>
			</div>
		</div>
	</div>
	<div class="right">
		<p>Javascript如何实现继承?
<!--break--></p>
<h3 id="继承inherit">继承（inherit）</h3>

<p>继承是什么？<em>继承是</em>指一个对象直接使用另一对象的属性和方法。也指按照法律或遵照遗嘱接受死者的财产、职务、头衔、地位等。</p>

<p>Javascript实现继承有原型链继承，构造继承，实例继承，组合继承，寄生继承。</p>
<h5 id="1父类">1.父类</h5>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Animal(name){
  this.name = name || 'Animal'; //属性
  this.sleep = function(){
      console.log(this.name + ' is sleeping'); 
  } //实例方法
}
Animal.prototype.eat = function(food){
	console.log(this.name + ' eat ' +food );
} //原型方法 ##### 2.原型链继承 将父类实例作为子类原型,复制父类的实例属性和原型方法。
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Cat (){
}
Cat.prototype = new Animal();
Cat.prototype.name = 'cat';

// Test Code
var Animal = new Animal();
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat.eat('mouse'));
console.log(cat instanceof Animal);
console.log(cat instanceof Cat);
</code></pre></div></div>

<p>实例是子类的实例，也是父类的实例</p>

<h5 id="3构造继承">3.构造继承</h5>
<p>使用父类的构造函数来增强子类实例，等于复制父类的实例属性。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat.eat('mouse'));
console.log(cat instanceof Animal);
console.log(cat instanceof Cat); ##### 4.实例继承 为父类实例添加新特性，作为子类实例返回。
function Cat(name){
  var instance = new Animal();
  instance.name = name || 'name';
  return instance;
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat.eat('mouse'));
console.log(cat instanceof Animal);
console.log(cat instanceof Cat); ##### 5.组合继承 构造继承和原型继承的结合，缺点调用了两次父类构造函数，生成两份实例。

function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
Cat.prototype = new Animal();

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat.eat('mouse'));
console.log(cat instanceof Animal);
console.log(cat instanceof Cat); ##### 6.寄生组合继承 通过寄生方式，砍掉父类的实例属性。在调用两次父类的构造的时候，就不会初始化两次实例方法/属性。 function Cat(name){
Animal.call(this);
this.name = name || 'Tom'; } (function (){
var Super = function(){};
Super.prototype = Animal.prototype;
Cat.prototype = new Super(); })(); // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat.eat('mouse')); console.log(cat instanceof Animal); console.log(cat instanceof Cat);
</code></pre></div></div>

	</div>
</div>


　　</body>
</html>
